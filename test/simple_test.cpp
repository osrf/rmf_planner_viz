/*
 * Copyright (C) 2020 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

#include <SFML/Graphics.hpp>
#include <imgui.h>

#include <iostream>

#include <rmf_planner_viz/draw/Graph.hpp>
#include <rmf_planner_viz/draw/Schedule.hpp>
#include <rmf_planner_viz/draw/IMDraw.hpp>
#include <rmf_planner_viz/draw/Trajectory.hpp>

#include <rmf_traffic/schedule/Database.hpp>
#include <rmf_traffic/agv/Planner.hpp>
#include <rmf_traffic/agv/debug/Planner.hpp>
#include <rmf_traffic/geometry/Circle.hpp>

#include "imgui-SFML.h"

// Hacky method to access the underlying container of std::priority_queue
// normally we'll derive off std::priority_queue and add a get_container function
// but this will suffice for the debugger's purposes
// Returned container will not provide any guarantees about order
template <class T, class S, class C>
S& get_priority_queue_container(std::priority_queue<T, S, C>& queue)
{
  struct HackedQueue : private std::priority_queue<T, S, C> 
  {
    static S& Container(std::priority_queue<T, S, C>& queue) 
    {
      return queue.*&HackedQueue::c;
    }
  };
  return HackedQueue::Container(queue);
}

int main()
{
  sf::Font font;
  if (!font.loadFromFile("./build/rmf_planner_viz/fonts/Ubuntu-B.ttf"))
  {
    std::cout << "Failed to load font. Make sure you run the executable from the colcon directory" << std::endl;
    return -1;
  }
  
  const rmf_traffic::Profile profile{
    rmf_traffic::geometry::make_final_convex<
      rmf_traffic::geometry::Circle>(1.0)
  };

  const rmf_traffic::agv::VehicleTraits traits{
    {0.7, 0.3},
    {1.0, 0.45},
    profile
  };

  const std::string test_map_name = "test_map";
  rmf_traffic::agv::Graph graph_0;
  graph_0.add_waypoint(test_map_name, {0.0, -10.0}); // 0
  graph_0.add_waypoint(test_map_name, {0.0, -5.0});  // 1
  graph_0.add_waypoint(test_map_name, {5.0, -5.0}).set_holding_point(true);  // 2
  graph_0.add_waypoint(test_map_name, {-10.0, 0.0}); // 3
  graph_0.add_waypoint(test_map_name, {-5.0, 0.0}); // 4
  graph_0.add_waypoint(test_map_name, {0.0, 0.0}); // 5
  graph_0.add_waypoint(test_map_name, {5.0, 0.0}); // 6
  graph_0.add_waypoint(test_map_name, {10.0, 0.0}); // 7
  graph_0.add_waypoint(test_map_name, {0.0, 5.0}); // 8
  graph_0.add_waypoint(test_map_name, {5.0, 5.0}).set_holding_point(true); // 9
  graph_0.add_waypoint(test_map_name, {0.0, 10.0}); // 10
  graph_0.add_waypoint(test_map_name, {5.0, 10.0}); // 11
  graph_0.add_waypoint(test_map_name, {-12.0, 10.0}); // 12

  /*            0<------------1<------------2
   *                                        ^
   *                                        |
   *  12------------->10----->11            |
   *                   |      |             |
   *                   |      v             |
   *                   8------9             |
   *                   |      |             |
   *                   |      |             |
   *     3------4------5------6------7      3
   *                   |      |
   *                   |      |
   *                   1------2
   *                   |
   *                   |
   *                   0
   **/

  auto add_bidir_lane = [&](const std::size_t w0, const std::size_t w1)
    {
      graph_0.add_lane(w0, w1);
      graph_0.add_lane(w1, w0);
    };

  add_bidir_lane(0, 1);
  add_bidir_lane(1, 2);
  add_bidir_lane(1, 5);
  add_bidir_lane(2, 6);
  add_bidir_lane(3, 4);
  add_bidir_lane(4, 5);
  add_bidir_lane(5, 6);
  add_bidir_lane(6, 7);
  add_bidir_lane(5, 8);
  add_bidir_lane(6, 9);
  add_bidir_lane(8, 9);
  add_bidir_lane(8, 10);
  graph_0.add_lane(10, 11);
  graph_0.add_lane(11, 9);
  graph_0.add_lane(12, 10);

  rmf_planner_viz::draw::Graph graph_0_drawable(graph_0, 1.0, font);

  rmf_traffic::agv::Graph graph_1;
  graph_1.add_waypoint(test_map_name, {-5.0, 15.0}); // 0
  graph_1.add_waypoint(test_map_name, { 5.0, 15.0}); // 1
  graph_1.add_waypoint(test_map_name, {15.0, 15.0}); // 2
  graph_1.add_waypoint(test_map_name, {15.0,  0.0}); // 3
  graph_1.add_lane(1, 0);
  graph_1.add_lane(2, 1);
  graph_1.add_lane(3, 2);

  rmf_planner_viz::draw::Graph graph_1_drawable(graph_1, 0.5, font);

  std::shared_ptr<rmf_traffic::schedule::Database> database =
      std::make_shared<rmf_traffic::schedule::Database>();

  rmf_traffic::agv::Planner planner_0(
        rmf_traffic::agv::Planner::Configuration(graph_0, traits),
        rmf_traffic::agv::Planner::Options(nullptr));

  /// Setup participants
  auto p0 = rmf_traffic::schedule::make_participant(
        rmf_traffic::schedule::ParticipantDescription{
          "participant_0",
          "simple_test",
          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
          profile
        },
        database);

  auto p1 = rmf_traffic::schedule::make_participant(
        rmf_traffic::schedule::ParticipantDescription{
          "participant_1",
          "simple_test",
          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
          profile
        },
        database);

  auto pa = rmf_traffic::schedule::make_participant(
        rmf_traffic::schedule::ParticipantDescription{
          "participant_0",
          "simple_test",
          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
          profile
        },
        database);

  auto pb = rmf_traffic::schedule::make_participant(
        rmf_traffic::schedule::ParticipantDescription{
          "participant_0",
          "simple_test",
          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
          profile
        },
        database);

//  auto pc = rmf_traffic::schedule::make_participant(
//        rmf_traffic::schedule::ParticipantDescription{
//          "participant_0",
//          "simple_test",
//          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
//          profile
//        },
//        database);

  auto p2 = rmf_traffic::schedule::make_participant(
        rmf_traffic::schedule::ParticipantDescription{
          "participant_2",
          "simple_test",
          rmf_traffic::schedule::ParticipantDescription::Rx::Responsive,
          profile
        },
        database);


  // set plans for the participants
  const auto now = std::chrono::steady_clock::now();

  std::vector<rmf_traffic::agv::Planner::Start> starts;
  starts.emplace_back(now, 11, 0.0);
  // starts.emplace_back(now, 12, 0.0);
  // starts.emplace_back(now, 10, 0.0);

  //p0.set(planner_0.plan(starts[0], 3)->get_itinerary());
  // p1.set(planner_0.plan(starts[1], 2)->get_itinerary());
  // p2.set(planner_0.plan(starts[2], 7,
  //   rmf_traffic::agv::Plan::Options(
  //   rmf_traffic::agv::ScheduleRouteValidator::make(
  //       database, p2.id(), p2.description().profile())))->get_itinerary());

  rmf_traffic::agv::Planner::Goal planner_goal(3);
  rmf_traffic::agv::Planner::Debug planner_dbg_0(planner_0);
  rmf_traffic::agv::Planner::Debug::Progress progress =
    planner_dbg_0.begin(starts, planner_goal, planner_0.get_default_options());

  rmf_utils::optional<rmf_traffic::agv::Plan> current_plan;
  
  //rmf_traffic::agv::Planner::Progress planner_dbg_0(planner_0);
  rmf_planner_viz::draw::Schedule schedule_drawable(
        database, 0.25, test_map_name, now);

  rmf_planner_viz::draw::Fit fit(
    {graph_0_drawable.bounds(), graph_1_drawable.bounds()}, 0.02);

  sf::RenderWindow app_window(
        sf::VideoMode(1250, 1028),
        "Simple Test",
        sf::Style::Default);

  app_window.resetGLStates();

  ImGui::SFML::Init(app_window);

  sf::Clock deltaClock;
  while (app_window.isOpen())
  {
    sf::Event event;
    while (app_window.pollEvent(event))
    {
      ImGui::SFML::ProcessEvent(event);

      if (event.type == sf::Event::Closed)
      {
        return 0;
      }

      if (event.type == sf::Event::Resized)
      {
        sf::FloatRect visibleArea(0, 0, event.size.width, event.size.height);
        app_window.setView(sf::View(visibleArea));
      }

      if (event.type == sf::Event::MouseButtonPressed)
      {
        const sf::Vector2f p =
            fit.compute_transform(app_window.getSize()).getInverse()
            * sf::Vector2f(event.mouseButton.x, event.mouseButton.y);

        const auto pick = graph_0_drawable.pick(p.x, p.y);
        if (pick)
          graph_0_drawable.select(*pick);
      }
    }

    ImGui::SFML::Update(app_window, deltaClock.restart());

    ImGui::SetWindowSize(ImVec2(600, 200));
    ImGui::Begin("Demo control panel", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
    ImGui::TextColored(ImVec4(0, 1, 0, 1), "Demo control panel");
    ImGui::End();
    
    // Planner debugging
    ImGui::SetWindowPos(ImVec2(800, 200));
    ImGui::SetWindowSize(ImVec2(600, 800));
    
    ImGui::Begin("Planner AStar Debug", nullptr, ImGuiWindowFlags_HorizontalScrollbar);

    static bool show_node_trajectories = true;
    ImGui::Checkbox("Show node trajectories", &show_node_trajectories);

    ImGui::Separator();
    if (ImGui::Button("Preset #0"))
    {
      
    }
    
    ImGui::Separator();

    if (ImGui::TreeNode("Current Plan"))
    {
      ImGui::Text("Starts: ");
      for (uint i=0; i<starts.size(); ++i)
      {
        ImGui::Text("#%d", i);
        ImGui::Text("Time: %f", starts[i].time().time_since_epoch());
        ImGui::Text("Waypoint: %d", starts[i].waypoint());
        ImGui::Text("Orientation: %d", starts[i].orientation());
      }

      //goals
      ImGui::NewLine();
      ImGui::Text("Goal waypoint: %d", planner_goal.waypoint());
      if (planner_goal.orientation())
        ImGui::Text("Goal orientation: %f", *planner_goal.orientation());
      else
        ImGui::Text("No chosen goal orientation");
      ImGui::TreePop();
    }
    ImGui::Separator();

    static auto plan_generation_timestamp = now;
    static float timeline_duration = 0.0f;
    static int steps = 0;
    ImGui::TextColored(ImVec4(0, 1, 0, 1), "AStar plan generation", steps);
    ImGui::TextColored(ImVec4(0, 1, 0, 1), "Steps taken: %d", steps);
    if (ImGui::Button("Step Forward"))
    {
      current_plan = progress.step();
      ++steps;
      plan_generation_timestamp = std::chrono::steady_clock::now();
    }
    if (ImGui::Button("Reset"))
    {
      progress = planner_dbg_0.begin(starts, planner_goal, planner_0.get_default_options());
      steps = 0;
      current_plan.reset();
    }
    
    ImGui::Separator();

    static std::vector<rmf_planner_viz::draw::Trajectory> trajectories_to_render;
    trajectories_to_render.clear();
    
    if (current_plan)
    {      
      auto searchqueue = progress.queue();
      auto& container = get_priority_queue_container(searchqueue);

      ImGui::TextColored(ImVec4(0, 1, 0, 1), "AStar Node Count: %d", container.size());
      ImGui::NewLine();

      static int selected_idx = -1;
      if (ImGui::ListBoxHeader("AStar Nodes"))
      {
        for (uint i=0; i<container.size(); ++i)
        {
          auto& node = container[i];
          node->route_from_parent;
          node->parent;
          char node_name[32] = { 0 };
          snprintf(node_name, sizeof(node_name), "Node %d (score: %f)",
            i, node->current_cost + node->remaining_cost_estimate);
          if (ImGui::Selectable(node_name, (int)i == selected_idx))
            selected_idx = i;
        }
        ImGui::ListBoxFooter();
      }
      
      ImGui::NewLine();
      ImGui::Separator();
      if (selected_idx != -1)
      {
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Node #%d Inspection", selected_idx);
        auto selected_node = container[selected_idx];
        ImGui::Text("Current Cost: %f", selected_node->current_cost);
        ImGui::Text("Remaining Cost Estimate: %f", selected_node->remaining_cost_estimate);
        ImGui::Text("Waypoint: %d", selected_node->waypoint);
        if (selected_node->start_set_index)
          ImGui::Text("start_set_index: %d", *selected_node->start_set_index);
        

        const rmf_traffic::Route& route = selected_node->route_from_parent;
        if (route.trajectory().start_time())
          ImGui::Text("Node Traj start time: %llu",  route.trajectory().start_time()->time_since_epoch());
        if (route.trajectory().finish_time())
          ImGui::Text("Node Traj finish time: %llu", route.trajectory().finish_time()->time_since_epoch());
        ImGui::Text("Node Traj duration: %f", rmf_traffic::time::to_seconds(route.trajectory().duration()));

        ImGui::NewLine();
        
        double max_duration = selected_node->current_cost + selected_node->remaining_cost_estimate;
        ImGui::SliderFloat("Timeline Control", &timeline_duration, 0.0f, static_cast<float>(max_duration));

        auto trajectory_time = rmf_traffic::time::apply_offset(plan_generation_timestamp, static_cast<double>(timeline_duration));

        auto add_trajectory_to_render = [trajectory_time, profile](
          std::vector<rmf_planner_viz::draw::Trajectory>& to_render,
          rmf_traffic::agv::Planner::Debug::ConstNodePtr node)
        {
          const rmf_traffic::Route& route = node->route_from_parent;
          auto trajectory = rmf_planner_viz::draw::Trajectory(route.trajectory(), 
            profile, trajectory_time, route.trajectory().duration(), sf::Color::Green, { 0.0, 0.0 }, 0.5f);
          to_render.push_back(trajectory);
        };
        add_trajectory_to_render(trajectories_to_render, selected_node);

        static bool render_parent_trajectories = false;
        ImGui::Checkbox("Render Parent Trajectories", &render_parent_trajectories);
        if (render_parent_trajectories)
        {
          auto parent_node = selected_node->parent;
          while (parent_node)
          {
            add_trajectory_to_render(trajectories_to_render, parent_node);
            parent_node = parent_node->parent;
          }
        }
        
      }
      else
        trajectories_to_render.clear();
    }
    else
      ImGui::TextColored(ImVec4(0, 1, 0, 1), "Current plan not available");

    ImGui::End();

    ImGui::EndFrame();

    //rmf_planner_viz::draw::IMDraw::draw_axis();

    /*** drawing ***/
    app_window.clear();

    schedule_drawable.timespan(std::chrono::steady_clock::now());

    sf::RenderStates states;
    fit.apply_transform(states.transform, app_window.getSize());
    app_window.draw(graph_0_drawable, states);
    app_window.draw(graph_1_drawable, states);
    app_window.draw(schedule_drawable, states);
    if (show_node_trajectories)
    {
      for (const auto& trajectory : trajectories_to_render)
        app_window.draw(trajectory, states);
    }

    rmf_planner_viz::draw::IMDraw::flush_and_render(app_window, states.transform);
    

    ImGui::SFML::Render(app_window);
    app_window.display();
  }
}
